1. Оценка актуальности пректа. 
На сегодняшний день отмечается рост интереса к развлекательным и культурно-просветительским заведениям, таким как музеи, театры, кинотеатры, и библиотеки. Информационные технологии успешно решают проблемы в различных сферах, включая работу с клиентами. Однако в театральной области Российской Федерации замечается недостаточное использование высоких технологий, несмотря на высокий спрос. Внутренние потребности театров включают в себя обработку данных, работу с клиентами и анализ продаж, что требует современных технологий. Для решения этой проблемы Александрийский театр разработал свою CRM-систему, обеспечивающую эффективное взаимодействие с клиентами и анализ продаж. Это подчеркивает актуальность создания программного обеспечения для театральных организаций. Разработка такого ПО требует особого внимания к процессу разработки, основанному на архитектурном подходе, модульности написания и экономии ресурсов системы
На фоне этого можно выделить ключевую проблему исследования в рамках проекта, а именно, разработку структурированного и гибкого класса "Театр" на языке C++, способного эффективно управлять информацией о залах, постановках, свободных и забронированных местах и других аспектах театральной деятельности и предоставлять пользователю посредством интерфейсных методов возможность удобной работы с объектами этого класса через консоль.
2. Цели проекта:
•	закрепление полученных в процессе курса «технологии и методы программирования» навыков разработки ПО с использованием принципов и методов объектно-ориентированного программирования (ООП) через написание программного продукта, решающего проблему данной НИР;
•	освоение архитектурного (модульного) подхода к  разработке ПО;
•	проектирование и реализация класса для процессов управления данными театра, позволяющее осуществлять ввод и вывод информации о предстоящих постановках, составление расписания, удобную работу с большим набором данных, бронирование мест и быстрый поиск.
3. Задачи пректа: 
•	исследовать и описать предметную область;
•	организовать связь между полями основного класса и структур данных;
•	реализовать основные методы работы с данными, указанными в требовании к программе;
•	осуществить возможности функций для администрирования и бронирования списка постановок;
•	разработать пользовательское консольное меню, позволяющее в полной мере проверить работу с объектами класса «Театр»;
•	протестировать программу на работу с некоторым набором входных данных.
4.	Описание структуры пользовательского меню
Поскольку конечный результат должен быть доступным и понятным в использовании широкому кругу лиц, необходимо сделать возможным управление разрабатываемого класса без взаимодействия с кодом проекта. Для этого в программе должны быть приписаны пользовательские меню. Во время исследования предметной области работы было принято соглашение о том, что пользователь будет взаимодействовать с классом theater посредством консольного ввода и вывода данных. Из-за обилия функционала класса разобьём пользовательское меню на три смысловые составляющие:
•	меню создания объекта класса theater;
•	меню работы с основными функциями созданного объекта;
•	меню проверки работы перегруженных операторов класса.
5. Алгоритмы и методы в программе
После проектирование приложения театра, можно переходить непосредственно к реализации его функционала. Дадим определение структурным типам, являющихся составными типами. К ним относятся уже оговорённые ранее структуры зала (hall), даты (Date), времени (Time) и записи постановки (play).
Для начала введём структурный тип данных для залов. Его именем будет hall. В качестве полей пользовательского типа hall были выбраны были выбраны целочисленные встроенные типы данных, отождествлённые соответственно с количеством рядов и мест в одном ряде. Помимо этого здесь представлены и функции-члены структуры: конструктор с параметрами, задающими поля структуры, перегрузка оператора присваивания и конструктор по умолчанию, нужный как в этом, так и в остальных определяемых в программе пользовательских типах для создания объекта или переменной этого типа без прямой инициализации для случаев, когда неизвестно, какое значение должен иметь этот объект. В  случае залов значениями по умолчанию являются ноль рядов и ноль мест в ряде зала. Отдельно выделим оператор присваивания, который в дальнейшем может пригодится для изменения или переноса значения. Он принимает ссылку на объект правого операнда, чтобы не вызывать лишний раз конструктор копирования и изменяет правый операнд, делая их равными полям левого операнда.
Теперь рассмотрим пользовательские структуры даты и времени. Структура даты Date состоит из трёх переменных полей типа string, которое будут выражать натуральное число, не превышающее разумных пределов. Решение хранить дату в виде строк было принято для того, так как осуществлять писок по неполным данным ведённой даты проще работая с функциями класса string, а также для того, чтобы при введении в поля даты некорректных символов, не являющихся цифрами, программа не выходила из строя, и этот ввод можно было бы идентифицировать с помощью функций работы со строками. Помимо этого в определении Date имеются следующие функции-члены: конструктор по умолчанию, конструктор с параметрами, принимающем строки, эквивалентные соответственно порядковому номеру дня в месяце, номеру месяца в году и году определяемой даты, перегрузка оператора «=», которая здесь нужна по той же причине, что и для типа hall, и перегрузка оператора сравнения дат, которая проверяет, совпадают ли поля экземпляров структуры. Перегрузка оператора «==» нужна для сокращения записи сравнения переменных типа для постановок.
Структура времени нужна для определения времени проведения постановки. Она состоит из строковых переменных, представляющих собой час и минуты начала сценического представления. Такое определение полей структуры Time обусловлено тем же, что и в случае с типом Date. Аналогично структуре Date здесь имеются следующие функции-члены: конструктор по умолчанию, конструктор с параметрами, принимающими значения часа и минут, перегрузка оператора присваивания и перегрузка оператора сравнения.
Теперь же, когда было дано определение элементарных пользовательских структур данных, перейдём к реализации более сложной структуры, описывающей запись планируемой в театре постановки. Она уже будет содержать в себе определённые ранее пользовательские типы. Описание записи постановке имеет следующий вид.
Из рисунка видно, что запись о постановке struct play содержит поле имени строкового типа (name), поля даты (date) типа Date и времени (time) типа Time проведения постановки, поле жанра строкового типа (ganre), поле цены (price) так же строкового типа, что обусловлено необходимостью предотвращения поломки программы при введении нечисловых данных в эту область памяти, поле номера зала целочисленного типа (num_hall), обозначающего порядковый номер зала театра, в котором будет проводиться постановка, а также определение этого зала, содержащейся в переменной play_h типа hall, которая определяется автоматически по номеру зала в театре и его характеристикам, и поле вектора с именем seats, содержащего векторы, хранящие логические переменные типа bool, необходимый для хранения данных о забронированных местах на указанную постановку, где true обозначит свободное место, false — забронированное.
Отдельное внимание обратим на функции-члены, содержащиеся в структуре записи о постановке. В первую очередь стоит описать конструкторы. Конструктор по умолчанию не создаёт полноценную переменную, а лишь определяет пустую запись. Конструктор с параметрами принимает 7 аргументов в следующем порядке: название постановки, дата её проведения, время начала её проведения, её жанр, цену билета, номер зала и параметры зала, хранящиеся в передаваемом аргументе типа hall. Все эти значения он напрямую инициализирует каждому полю структуры.
Так же как и для предыдущих пользовательских типов данных, в представлении рассматриваемой структуры имеются и функции-члены, перегружающие операторы присваивания «=» и сравнения «==».
Если в случае с оператором присваивания всё понятно: для операнда, стоящего слева, поразрядно, в рамках каждого поля, присваиваются значения операнда, расположенного справа, то в случае с оператором сравнения стоит пояснить, что эквивалентными (равными) записями о постановках считаются такие переменные, у которых одновременно совпадает и наименование, и время проведения (дата и время), и место проведения (номер зала), и жанр постановки. Конечно же это равенство имеет смысл только в области действия одного театра.
Далее определим немаловажный оператор вывода записи о постановке в консоль. Как можно было заметить, функция перегрузки оператора вывода является дружественной для структуры play. Перегрузка вывода первым аргументом принимает ссылку на поток типа ostream, определённым в классе ios, вторым аргументом она принимает ссылку на выводимую структурную переменную данного типа. Она также возвращает ссылку на поток, чтобы было возможно записывать вывод переменных типа play в ряд. Первым делом в консоль выводиться наименование спектакля, затем ставиться разделитель, чтобы показать, что все дальнейшие параметры относятся к постановке с выведенным именем. Отдельное внимание стоит обратить на назначение функций fill и width, которые здесь выводят дополнительный ноль в случае, если значения дня, месяца даты или значения часа и минуты содержат лишь один символ. Для читаемости и красоты вывода все характеризующие постановку параметры выводятся через табуляцию. Особое внимание стоит обратить на вывод количества свободных мест, необходимый, чтобы пользователь/клиент уже на старте мог сделать оценку того, сможет ли он занять нужное ему место в зале или нет. Это делается возможным благодаря функции free_place, которая перебирает все места в зале и считает только те позиции вектора, которые равны true.
После того как были определены все составляющие класса theater можно перейти к рассмотрению структуры устройства самого театра.
В закрытой части класса theater, хранятся следующие поля: наименование театра, список планируемых постановок, хранящихся в векторе vector<play> play_t, количество залов, составляющих театр и определение каждого из этих залов, хранящееся в переменных типа hall, расположенных в свою очередь в массиве, ссылку на первый элемент которого хранит указатель halls. Заметим, что порядковый номер каждого зала начинается с единицы и соответствует номеру его расположения в массиве залов театра. Тот факт, что эти поля являются закрытыми от произвольного доступа к данным, хранящимся в ИС обусловлен ограничением возможности хаотического управления данными объекта класса, без их контроля его функциями.
Прежде чем начинать описывать функционал класса для работы с данными, необходимо эти данные определить и присвоить полям для хранения в объекте. С этой задачей призваны справиться конструкторы класса. Для разрабатываемого класса theater реализовано пять различных конструкторов. Сущность их назначения в программе хоть и одинакова, однако количество аргументов и способы инициализации полей различны.
В первую очередь стоит определить конструктор по умолчанию, который создаёт театр с ничего не содержащим набором данных. Такой конструктор нужен для определения объектов класса theater в тех случаях, когда заранее неизвестно, какие данные следует хранить в объекте такого класса, хотя его уже нужно определять в программе.
Теперь же определим один из конструкторов с параметрами, который принимает в качестве аргументов наименование театра, количество залов и указатель на первый элемент массива залов.
Обработчик исключительных ситуаций в функции необходим в случае, если размер передаваемого массива меньше заявленного количество залов. Тогда динамическая память, выделяемая под массив залов, удаляется и инициализация объекта не происходит. В благоприятных случаях происходит примитивное присваивание. Логично будет следующим шагом определить конструктор класса theater, инициализирующий объект театра с определённым количеством залов, равным count, с одинаковыми характеристиками тогда риск выхода за пределы массива почти сводится к нулю. 
Наличие конструктора копирования обусловлено тем, что при инициализации объекта класса выделяется динамическая память, на начало которой указывает halls, поэтому необходимо напрямую прописывать инициализацию копии, чтобы указатель копии хранил адрес уже на другую область памяти для хранения данных о залах, относящуюся только к этой копии. В противном случае будет происходить примитивное поразрядное присваивание полям копии полей данных оригинала, и указатель halls копии будет указывать на ту же область памяти, что и этот же указатель оригинала, а это в свою очередь может привести к непредсказуемой работе программы.
Перед тем, как описывать реализацию последнего конструктора класса, необходимо прописать следующую очень важную функцию, которая будет использована в коде программы ещё не раз.
Назначение функции my_stoi() заключается в преобразовании строки в целочисленное значение. Для обеспечения такого функционала внутри функции прописана строка sh, в которой содержатся символы от 0 до 9, то есть индекс каждого из этих символов в строке соответствует значению этого символа. Начальное значение k равно 0, то есть пустая стока для данной функции равна 0. Для ненулевой строки функция подключает цикл, в котором для каждого символа строки str проверяет, есть и она в строке sh. Если рассматриваемый символ является цифрой, то разряд числа k увеличивается на 10 и к этому значению прибавляется значение индекса возвращённого значения. Если же рассматриваемого символа в строке нет, что определяется по флажку, то полученная строка не может быть преобразована в целое неотрицательное число, поэтому программа возвращает значение -1. 
Теперь определим конструктор, считывающий данные о театре с файла. Функция в качестве аргумента получает название файла, типа string, обозначающий имя файла, вызывает конструктор класса ifstream, открывающий поток ввода с файла, затем проверяет, может ли быть открыт этот файл, с помощью функции is_open(), в случае ошибки открытия файла произойдёт выброс исключения, и программа завершит выполнение, иначе продолжается считывание с файла в соответствии со строго определённой формой хранения данных: в первой ячейке хранится наименование театра, во второй – количество залов, в третьей - определения каждого из залов: сначала идёт количество рядов, затем через пробел количество мест в ряде. Если в файле указанное количество залов и количество определений залов не совпадают или в файле нет необходимых разделителей, то выбрасывается исключение. В лучшем случае функция приступает к считыванию информации о рядах и залах. Функция dig призвана определить, не содержаться ли в значении количеств недопустимых символов, если программа их обнаружит, то попросит пользователя вручную ввести эти данные в консоль.
Функция dig основана на той же концепции, что и функция my_stoi(), только её задача более ограничена, так как она должна просто идентифицировать, содержатся ли в строке только цифры (true) или имеются иные символы (false). 
Теперь перейдём к рассмотрению функций сортировок списка постановок. Функция сортировки по времени sort_time, устанавливается по умолчанию. Идея сортировки заключается в том, чтобы найти запись постановки, которая планируется позднее всех, и переместить её на последнюю позицию, затем уменьшить диапазон поиска на один элемент массива и искать более позднее представление в рамках выделенного подмножества. В тех случаях, когда постановки планируются в одно и то же время, постановки сортируются по номерам залов следующим образом, постановка с большим номером зала ставится ниже постановки с меньшим номером. В классе также имеется функция сортировки по полю названия постановки sort_name, сортирующая тем же способом, что и sort_time(), но постановки будут расположены уже в лексикографическом порядке их наименований, то есть по алфавиту.
Отдельно следует рассмотреть функцию добавления постановки. Основной задачей этой функции является проверка переданных ей данных о постановке на корректность, и требование от пользователя изменить их на допустимые. Аргументам этой функции соответствуют ранее указанные атрибуты записи о постановке. Будем рассматривать каждый аргумент по мере его появления в листинге кода функции. Первым делом программа проверяет на корректность предложенную дату (Date) проведения. Для этого она должна знать текущую дату, которая берётся из функции cur_date, которая, в свою очередь, обращается к ОС. Далее в функции проверяется, чтобы дата не имела в своём значении недопустимых символов и не являлась прошлой. Здесь и во многих других местах кода предусмотрена возможность введения месяца с помощью слов. Для того, чтобы понять, состоит ли строка только из буквенных символов используется функция only_let. Слова, обозначающие месяц могут таже вводиться в любом регистре, так как их идентификация происходит с помощью сравнения строк, прописные буквы которых преобразованы в строчные. Это является возможным благодаря функции lowercase которая, принимая строку, возвращает ту же самую строку, но в пониженном регистре, если в ней имелись прописные буквы. 
В функции only_let() для идентификации того, что рассматриваемый символ является буквой русского либо латинского алфавита, используется строка А, в которой перечислены все эти буквы. Если при рассмотрении какого-то конкретного символа, он не встречается в этой строке, то флажок f не увеличивается, а значит конечное значение флажка не совпадёт с длиной строки. Если же все символы являются буквами, то значение f равно количеству символов. Функция lowercase, если встречает в строке прописную букву, заменяет её строчной буквой из строки a с тем же индексом.
Далее функция add_play проверяет на допустимость значения часа и минут. Проверка жанра, цены и номера зала осуществляется аналогичным образом. Только в случае проверки жанра применяется функция only_let_cap которая является дополнением функции only_let, но с дополнительной проверкой на начало строки с прописной буквы, поскольку жанр должен содержать прописную букву только в начале. А для проверки цены добавляется функция dig_price, которая допускает наличие одной точки в строке цены. Функция add_play не допускает добавления постановки, которая будет происходить одновременно с уже имеющейся в списке в одном и том же зале.
Здесь также происходит проверка забронированных мест и создания вектора, хранящего информацию о свободных и забронированных местах. Это необходимо в первую очередь для определения забронированных мест на постановки, считанных из файла. У каждого забронированного места есть своя форма записи в файле: {номер ряда}.{номер места}, эти обозначения разделены между собой пробелами. Именно поэтому здесь вызываются исключения, так как в случаях, когда считываются некорректные забронированные места, считывание с файла должно прекратиться. В противном случае все последующие данные будут считываться некорректно. После прохождения всех представленных проверок создаётся переменная типа play, она добавляется в вектор списка постановок и этот вектор сортируется по времени с помощью sort_time.
Функция del_play удаляет запись о постановке по её порядковому номеру в списке. В случае, если введённый индекс постановки выходит за пределы массива или массив списка постановок пуст, функция возвращает ошибку, в лучшем случае она уточняет у пользователя, действительно ли он хочет удалить запись, и при положительном ответе удаляет запись.
Функция add_hall добавляет зал в театр. Она выделяет память под новый динамический массив. В его конец добавляет переданную в качестве аргумента переменную типа hall. Удаляет старый динамический массив и присваивает halls адрес на первый элемент нового массива залов. Функция del_hall позволяет удалить зал из театра. Но перед этим она проверяет возможность этого действия, так как если на какую-то постановку забронированы места, то удалить нельзя. При благоприятном результате функция перезаписывает в новый массив все залы старого массива, пропуская удаляемый элемент, удаляет старый массив и присваивает halls указатель на первый элемент нового массива.
Перегрузка оператора вывода информации о театре, как и в случае с play, является функцией, дружественной к классу theater. Она окаймляет вывод информации о театре сверху и снизу, выводит все атрибуты через табуляцию, среди который данные о залах и их характеристиках: количество рядов и мест в ряде.
Функция считывания списка постановок с файла fread принимает на вход наименование файла и структурно действует так же, как и конструктор считывания данных о театре с файла. Она также проверяет форму хранения данных: наличие у записи даты точек, наличие у записи времени двоеточия. В случае, когда строка с забронированными местами имеет недопустимые значения, она закрывает поток ввода из файла и выбрасывает исключение. Она использует функцию add_play для добавления постановки.
Функция fwrite принимает два аргумента, обозначающих названия файлов: в первый файл записываются данные о театре, во второй - список постановок. Запись в файл происходит в соответствии с необходимой формой записи так, чтобы с получившихся файлов программа в дальнейшем смогла считать данные.
Функция print_play имеет две реализации: одну без аргументов, тогда она будет выводить весь список постановок театра, а другую с аргументами, среди которых некоторое подмножество постановок и вектор с порядковыми номерами этих постановок в общем списке. Вторая форма нужна при поиске записи о постановке и получении его порядкового номера.
В классе реализован целый ряд поисков по разным полям: по наименованию постановки, по её жанру, по дню в месяце, месяцу, году её проведения, залу, дате и времени проведения в целом. Реализация всех этих функций идентична и различается лишь в поле поиска (для даты и времени комбинируются поиски по дню, месяцу и году для даты, и по часу и минутам для времени). Их основная идея заключается в использовании в сравнении строк функций lowercase для регистронезависимого поиска и функции find библиотеки <string> для поиска по неполным данным. Они возвращают подмножество удовлетворяющих условию поиска постановок для его передачи функции print_play.
Отдельно следует рассмотреть функции, реализующие систему бронирования места на постановку по порядковому номеру постановки в списке. Каждая из них реализует своё мини-меню. Например, функция book_place позволяет пользователю как узнать о свободных местах, переводя его в функцию print_hall,  так и непосредственно забронировать место, или выйти из метода. Если введённое место существует или свободно, то при бронировании оно приобретёт значение false в векторе seats. Функция print_hall тоже позволяет пользователю выбирать, каким способом он хочет узнать о свободных местах: графическим, то есть выводом в консоль с помощью условных обозначений, или тестовым, то есть в виде номеров свободных мест выбранного ряда.
Оператор присваивания будет стирать все данные операнда, стоящего слева, и присваивать освободившемся полям значения операнда, стоящего справа. Оператор же сложения двух театров будет работать так, словно создаётся новый театр, который является объединением двух складываемых театров. Функция перегрузки оператора «+» будет предлагать ввести наименование театра, затем она выделит память под массив залов, складываемый из залов правого и левого операнда, после чего номера залов левого операнда увеличатся на количество залов правого операнда, как в непосредственном определении, так и в определении залов. Затем в список постановок образующегося объекта перейдут все записи объединяемых театров, которой после будет отсортирован по времени с помощью функции sort_time.
6. Заключение
С использованием языка C++, был создан спроектирован и реализован класс "Театр", который предоставляет удобные интерфейсные методы для работы с информацией о постановках, залах, билетах и других аспектах театральной деятельности.
Разработка программного продукта предоставила возможность не только применить теоретические знания о языке программирования и ООП на практике , но и научиться построению модульных и гибких программ, эффективно управляющих данными. Консольное приложение, реализованное в ходе работы, взаимодействует с пользователем, предоставляя возможность ввода и вывода информации о представлениях, расписании, билетах и других важных аспектах театральной деятельности.
Таким образом, проект позволил не только решить конкретную проблему в области внедрения информационных технологий в сценический промысел, но и значительно расширить практические навыки в программировании, архитектурном проектировании и построении сложных систем. Полученные знания о структурах данных, ER-диаграммах и ООП предоставляют прочную основу для дальнейшего развития в области программной инженерии.










 
